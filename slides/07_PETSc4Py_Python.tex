%% This file was auto-generated by IPython, do NOT edit
%% Conversion from the original notebook file:
%% 07_PETSc4Py_Python.ipynb
%%
\documentclass[11pt,english]{article}

%% This is the automatic preamble used by IPython.  Note that it does *not*
%% include a documentclass declaration, that is added at runtime to the overall
%% document.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

% needed for markdown enumerations to work
\usepackage{enumerate}

% Slightly bigger margins than the latex defaults
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=2.5cm,rmargin=2.5cm}

% Define a few colors for use in code, links and cell shading
\usepackage{color}
\definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
\definecolor{darkorange}{rgb}{.71,0.21,0.01}
\definecolor{darkgreen}{rgb}{.12,.54,.11}
\definecolor{myteal}{rgb}{.26, .44, .56}
\definecolor{gray}{gray}{0.45}
\definecolor{lightgray}{gray}{.95}
\definecolor{mediumgray}{gray}{.8}
\definecolor{inputbackground}{rgb}{.95, .95, .85}
\definecolor{outputbackground}{rgb}{.95, .95, .95}
\definecolor{traceback}{rgb}{1, .95, .95}

% Framed environments for code cells (inputs, outputs, errors, ...).  The
% various uses of \unskip (or not) at the end were fine-tuned by hand, so don't
% randomly change them unless you're sure of the effect it will have.
\usepackage{framed}

% remove extraneous vertical space in boxes
\setlength\fboxsep{0pt}

% codecell is the whole input+output set of blocks that a Code cell can
% generate.

% TODO: unfortunately, it seems that using a framed codecell environment breaks
% the ability of the frames inside of it to be broken across pages.  This
% causes at least the problem of having lots of empty space at the bottom of
% pages as new frames are moved to the next page, and if a single frame is too
% long to fit on a page, will completely stop latex from compiling the
% document.  So unless we figure out a solution to this, we'll have to instead
% leave the codecell env. as empty.  I'm keeping the original codecell
% definition here (a thin vertical bar) for reference, in case we find a
% solution to the page break issue.

%% \newenvironment{codecell}{%
%%     \def\FrameCommand{\color{mediumgray} \vrule width 1pt \hspace{5pt}}%
%%    \MakeFramed{\vspace{-0.5em}}}
%%  {\unskip\endMakeFramed}

% For now, make this a no-op...
\newenvironment{codecell}{}

 \newenvironment{codeinput}{%
   \def\FrameCommand{\colorbox{inputbackground}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\endMakeFramed}

\newenvironment{codeoutput}{%
   \def\FrameCommand{\colorbox{outputbackground}}%
   \vspace{-1.4em}
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\medskip\endMakeFramed}

\newenvironment{traceback}{%
   \def\FrameCommand{\colorbox{traceback}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\endMakeFramed}

% Use and configure listings package for nicely formatted code
\usepackage{listingsutf8}
\lstset{
  language=python,
  inputencoding=utf8x,
  extendedchars=\true,
  aboveskip=\smallskipamount,
  belowskip=\smallskipamount,
  xleftmargin=2mm,
  breaklines=true,
  basicstyle=\small \ttfamily,
  showstringspaces=false,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{myteal},
  stringstyle=\color{darkgreen},
  identifierstyle=\color{darkorange},
  columns=fullflexible,  % tighter character kerning, like verb
}

% The hyperref package gives us a pdf with properly built
% internal navigation ('pdf bookmarks' for the table of contents,
% internal cross-reference links, web links for URLs, etc.)
\usepackage{hyperref}
\hypersetup{
  breaklinks=true,  % so long urls are correctly broken across lines
  colorlinks=true,
  urlcolor=blue,
  linkcolor=darkorange,
  citecolor=darkgreen,
  }

% hardcode size of all verbatim environments to be a bit smaller
\makeatletter 
\g@addto@macro\@verbatim\small\topsep=0.5em\partopsep=0pt
\makeatother 

% Prevent overflowing lines due to urls and other hard-to-break entities.
\sloppy

\begin{document}

\begin{center}
{\bf \Large PETSc4Py}

{\bf \large Python in HPC}

{\bf TACC Training, Oct. 15, 2012}
\end{center}

\noindent Presenters:

\noindent {\bf Andy R. Terrel, PhD}\\
Texas Advanced Computing Center\\
University of Texas at Austin\\

\noindent {\bf Yaakoub El Khamra}\\
Texas Advanced Computing Center\\
University of Texas at Austin\\

\href{http://creativecommons.org/licenses/by/3.0/deed.en\_US}{\includegraphics{figures/creative_commons_logo.png}}\\

\noindent Python in HPC Tutorial by Terrel, and El Khamra is licensed
under a Creative Commons Attribution 3.0 Unported License. \\[2em]

\href{http://www.tacc.utexas.edu}{\includegraphics[scale=0.8]{figures/TACC_logo.png}} \qquad

\newpage

\subsection{Interacting with the Tutorial Slides}

This tutorial is an interactive worksheet designed to encourage you to
try out the lessons during the demonstration. If you are looking at the
pdf version, we encourage you to download the updated version (see
previous slide) and try the interactive version.

To run the interactive version, you need a good Python environment
including:

\begin{itemize}
\item
  IPython version \textgreater{}= 13.0
\item
  Numpy version \textgreater{}= 1.5
\item
  Scipy
\item
  Matplotlib
\end{itemize}

Move to the directory containing the tarball and execute:

\begin{verbatim}
$ ipython notebook --pylab=inline
\end{verbatim}

We heartily endorse the
\href{https://store.continuum.io/cshop/anaconda}{Anaconda distribution}
and the \href{http://www.enthought.com/products/epd\_free.php}{Free
Enthought Python Distribution}.

\newpage

\subsection{Presentation mode}

 The slide show mode is only supported by an IPython development branch
version. To get it I recommend cloning from the official branch, adding
Matthias Carreau's remote, fetching and using his branch
slideshow\_extension2. Here are the commands:

\begin{verbatim}
git clone git://github.com/ipython/ipython.git # Official clone
cd ipython
git remote add carreau git://github.com/Carreau/ipython.git # Matthias' branch
git fetch carreau # Fetch the branches
git checkout carreau/slideshow_extension2 # Checkout the slideshow extension
python setup.py develop # Install the development version
ipython notebook # Check out the slideshows.
\end{verbatim}



\newpage

\subsection{Acknowledgements}

\begin{itemize}
\item
  petsc4py examples developed by
  \href{http://www.bu.edu/pasi/people/lisandro-dalcin/}{Lisandro Dalcin}
\item
  \href{http://code.google.com/p/petsc4py/}{petsc4py} petsc4py are
  Python bindings for \href{http://www.mcs.anl.gov/petsc/}{PETSc}, the
  Portable, Extensible Toolkit for Scientific Computation.
\end{itemize}

\newpage

\section{What is PETSc}

``PETSc\ldots{}is a suite of data structures and routines for the
scalable (parallel) solution of scientific applications modeled by
partial differential equations. It supports MPI,~shared memory pthreads,
and~NVIDIA GPUs, as well as hybrid MPI-shared memory pthreads or MPI-GPU
parallelism''

\newpage

\subsection{PETSc's Role}

Developing parallel, nontrivial PDE solvers that deliver high
performance is still difficult and requires months (or even years) of
concentrated effort. PETSc is a toolkit that can ease these difficulties
and reduce the development time, but it is not a black-box PDE solver,
nor a silver bullet. Barry Smith

\newpage

\subsection{What can you use it for?}

\begin{itemize}
\item
  Scientific Computations: parallel linear algebra, in particular linear
  and nonlinear solvers
\item
  Toolkit: Contains high level solvers, but also the low level tools to
  roll your own.
\item
  Portable: Available on many platforms, basically anything that has MPI
\end{itemize}

Why use it? It's big, powerful, well supported.

\newpage

\subsection{A bit more about PETSc}

What problems can it tackle:

\begin{itemize}
\item
  Serial and Parallel
\item
  Linear and nonlinear
\item
  Finite difference and finite element
\item
  Structured and unstructured
\end{itemize}

What is in PETSc:

\begin{itemize}
\item
  Linear system solvers (sparse/dense, iterative/direct)
\item
  Nonlinear system solvers
\item
  Tools for distributed matrices
\item
  Support for profiling, debugging, graphical output
\end{itemize}

And much much more

\newpage

\subsection{Where to learn more about PETSc}

\begin{itemize}
\item
  PETSc Tutorial at TACC
\item
  Regular tutorials by PETSc developers
\item
  \href{http://www.mcs.anl.gov/petsc/}{The PETSc website}
\item
  \href{http://www.mcs.anl.gov/petsc/documentation/index.html}{The PETSc
  documentation}
\item
  PETSc source code examples in the tarball
\end{itemize}

\newpage

\subsection{PETSc4Py}

\begin{itemize}
\item
  Python bindings for PETSc, the Portable Extensible Toolkit for
  Scientic Computation
\item
  Implemented with Cython
\item
  A good friend of petsc4py is:
\item
  mpi4py: Python bindings for MPI, the Message Passing Interface
\item
  Other two projects depend on petsc4py:
\item
  slepc4py: Python bindings for SLEPc, the Scalable Library for
  Eigenvalue Problem Computations
\item
  tao4py: Python bindings for TAO, the Toolkit for Advanced Optimization
\end{itemize}

\newpage

\subsection{Python for control and logic C for local computation}

\begin{itemize}
\item
  Decouple organization of storage from mathematical operations
\item
  Vectors are not arrays
\item
  Lots of small arrays
\item
  get/setValues() methods
\item
  Views into larger arrays
\item
  Dense, local computation is cache/bandwidth efficient
\end{itemize}

\newpage

\subsection{PETSc4Py Interface}

\begin{itemize}
\item
  Using PETSc4Py is very similar to using MPI4Py
\item
  Provides ALL PETSc functionality in a Pythonic way
\item
  Manages all memory (creation/destruction)
\item
  Visualization with matplotlib
\end{itemize}

\newpage

\subsection{PETSc4Py Basic Operations}

\begin{itemize}
\item
  Create a sparse matrix, set its size and type:
\item
  A = PETSc.Mat()
\item
  A.create(PETSc.COMM\_WORLD)
\item
  A.setSizes({[}m\emph{n, m}n{]})
\item
  A.setType(`mpiaij')
\item
  Create a linear solver and solve:
\item
  ksp = PETSc.KSP()
\item
  ksp.create(PETSc.COMM\_WORLD)
\item
  ksp.setOperators(A)
\item
  ksp.setFromOptions()
\item
  ksp.solve(b, x)
\end{itemize}

\newpage

\subsection{PETSc4Py Example}

2D Poisson problem: -Laplacian(u) = 1, 0 \textless{} x,y \textless{} 1

with boundary conditions u = 0 for x=0, x=1, y=0, y=1

\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
try: range = xrange
except: pass

import sys, petsc4py
petsc4py.init(sys.argv)

from petsc4py import PETSc

class Poisson2D(object):

    def __init__(self, da):
        assert da.getDim() == 2
        self.da = da
        self.localX  = da.createLocalVec()

    def formRHS(self, B):
        b = self.da.getVecArray(B)
        mx, my = self.da.getSizes()
        hx, hy = [1.0/m for m in [mx, my]]
        (xs, xe), (ys, ye) = self.da.getRanges()
        for j in range(ys, ye):
            for i in range(xs, xe):
                b[i, j] = 1*hx*hy

    def mult(self, mat, X, Y):
        #
        self.da.globalToLocal(X, self.localX)
        x = self.da.getVecArray(self.localX)
        y = self.da.getVecArray(Y)
        #
        mx, my = self.da.getSizes()
        hx, hy = [1.0/m for m in [mx, my]]
        (xs, xe), (ys, ye) = self.da.getRanges()
        for j in range(ys, ye):
            for i in range(xs, xe):
                u = x[i, j] # center
                u_e = u_w = u_n = u_s = 0
                if i > 0:    u_w = x[i-1, j] # west
                if i < mx-1: u_e = x[i+1, j] # east
                if j > 0:    u_s = x[i, j-1] # south
                if j < ny-1: u_n = x[i, j+1] # north
                u_xx = (-u_e + 2*u - u_w)*hy/hx
                u_yy = (-u_n + 2*u - u_s)*hx/hy
                y[i, j] = u_xx + u_yy

OptDB = PETSc.Options()

n  = OptDB.getInt('n', 16)
nx = OptDB.getInt('nx', n)
ny = OptDB.getInt('ny', n)

da = PETSc.DA().create([nx, ny], stencil_width=1)
pde = Poisson2D(da)

x = da.createGlobalVec()
b = da.createGlobalVec()
# A = da.createMat('python')
A = PETSc.Mat().createPython(
    [x.getSizes(), b.getSizes()], comm=da.comm)
A.setPythonContext(pde)
A.setUp()

ksp = PETSc.KSP().create()
ksp.setOperators(A)
ksp.setType('cg')
pc = ksp.getPC()
pc.setType('none')
ksp.setFromOptions()

pde.formRHS(b)
ksp.solve(b, x)

u = da.createNaturalVec()
da.globalToNatural(x, u)

from matplotlib import pylab
from numpy import mgrid

X, Y =  mgrid[0:1:1j*nx,0:1:1j*ny]
Z = x[...].reshape(nx,ny, order='F')
pylab.figure()
pylab.contourf(X,Y,Z)
pylab.plot(X.ravel(),Y.ravel(),'.k')
pylab.axis('equal')
pylab.colorbar()
pylab.show()    
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{center}
\includegraphics[width=6in]{07_PETSc4Py_Python_files/07_PETSc4Py_Python_fig_00.png}
\par
\end{center}
\end{codeoutput}
\end{codecell}
\newpage

\subsection{PETSc4Py and in parallel}

\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
# Some preliminaries to connect to the engines

from IPython.parallel import Client
c = Client()
view = c[:]

%load_ext parallelmagic
view.activate()
view.block = True
%autopx
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{verbatim}
%autopx enabled
\end{verbatim}
\end{codeoutput}
\end{codecell}
\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
try: range = xrange
except: pass

import sys, petsc4py
petsc4py.init(sys.argv)

from petsc4py import PETSc

class Poisson2D(object):

    def __init__(self, da):
        assert da.getDim() == 2
        self.da = da
        self.localX  = da.createLocalVec()

    def formRHS(self, B):
        b = self.da.getVecArray(B)
        mx, my = self.da.getSizes()
        hx, hy = [1.0/m for m in [mx, my]]
        (xs, xe), (ys, ye) = self.da.getRanges()
        for j in range(ys, ye):
            for i in range(xs, xe):
                b[i, j] = 1*hx*hy

    def mult(self, mat, X, Y):
        #
        self.da.globalToLocal(X, self.localX)
        x = self.da.getVecArray(self.localX)
        y = self.da.getVecArray(Y)
        #
        mx, my = self.da.getSizes()
        hx, hy = [1.0/m for m in [mx, my]]
        (xs, xe), (ys, ye) = self.da.getRanges()
        for j in range(ys, ye):
            for i in range(xs, xe):
                u = x[i, j] # center
                u_e = u_w = u_n = u_s = 0
                if i > 0:    u_w = x[i-1, j] # west
                if i < mx-1: u_e = x[i+1, j] # east
                if j > 0:    u_s = x[i, j-1] # south
                if j < ny-1: u_n = x[i, j+1] # north
                u_xx = (-u_e + 2*u - u_w)*hy/hx
                u_yy = (-u_n + 2*u - u_s)*hx/hy
                y[i, j] = u_xx + u_yy

OptDB = PETSc.Options()

# change nx and ny if you want
n  = OptDB.getInt('n', 16)
nx = OptDB.getInt('nx', n)
ny = OptDB.getInt('ny', n)

da = PETSc.DA().create([nx, ny], stencil_width=1)
pde = Poisson2D(da)

x = da.createGlobalVec()
b = da.createGlobalVec()
# A = da.createMat('python')
A = PETSc.Mat().createPython(
    [x.getSizes(), b.getSizes()], comm=da.comm)
A.setPythonContext(pde)
A.setUp()

ksp = PETSc.KSP().create()
ksp.setOperators(A)
ksp.setType('cg')
pc = ksp.getPC()
pc.setType('none')
ksp.setFromOptions()

pde.formRHS(b)
ksp.solve(b, x)

u = da.createNaturalVec()
da.globalToNatural(x, u)
x.getSizes()

engine_arrays = u.array
rank=da.comm.rank

\end{lstlisting}
\end{codeinput}
\end{codecell}
\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
# now disable the parallel run to get the d
%autopx
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{verbatim}
%autopx disabled
\end{verbatim}
\end{codeoutput}
\end{codecell}
\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
# view the engine arrays and ranks
arrays = view['engine_arrays']
ranks = view['rank']
# Sort the arrays based on rank
arrays_and_ranks = zip(ranks, arrays)
arrays_and_ranks.sort()
sorted_ranks,sorted_arrays = zip(*arrays_and_ranks)
\end{lstlisting}
\end{codeinput}
\end{codecell}
\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
# Create a list to use with concatenate
list_arrays=list(sorted_arrays)
# Concatenate the ordered list of arrays into one flat array
u_flat = concatenate(list_arrays, axis=0)
\end{lstlisting}
\end{codeinput}
\end{codecell}
\begin{codecell}
\begin{codeinput}
\begin{lstlisting}
# Get the global sizes nx and ny
nx=view['nx'][0]
ny=view['ny'][0]

# create a mesh grid
X, Y =  mgrid[0:1:1j*nx,0:1:1j*ny]
# reshape the solution, orderering is Fortran based
u = u_flat[...].reshape(nx,ny, order='F')

# Let's plot
pylab.figure()
pylab.contourf(X,Y,u)
pylab.plot(X.ravel(),Y.ravel(),'.k')
pylab.axis('equal')
pylab.colorbar()
pylab.show()
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}
\begin{center}
\includegraphics[width=6in]{07_PETSc4Py_Python_files/07_PETSc4Py_Python_fig_01.png}
\par
\end{center}
\end{codeoutput}
\end{codecell}
\end{document}
